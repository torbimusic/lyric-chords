import { NoteAlteration, AmericanNote, Notation } from '../constants';
import { NoteDistance } from './models/note-distance';
import { SouthernEuropeanNote } from '../constants/southern-european-note';
import { Interval } from '../interval/interval';
export declare class Note {
    private _note;
    private _alteration;
    private _absoluteValue;
    private static NOTES;
    private constructor();
    readonly note: AmericanNote;
    readonly alteration: NoteAlteration;
    /**
     * Represents a value for distinguish of diferents sound of notes.
     *
     * If the note are enharmonic, they have the same absolute value.
     *
     * It is used for internal functions.
     */
    readonly absoluteValue: number;
    /**
     * Find enharmonic note above
     *
     * e.g:
     ```
let note = Note.parse('C#')
    .enharmonicToNoteAbove()

note.toString() // Db
    ```
     
     *
     * @returns enharmonic note above or null if doesn't exists
     */
    enharmonicToNoteAbove(): Note;
    /**
     * Find enharmonic note below
     *
     * e.g:
     ```
let note = Note.parse('Db')
    .enharmonicToNoteBelow()

note.toString() // C#
```
     * @returns enharmonic note above or null if doesn't exists
     */
    enharmonicToNoteBelow(): Note;
    private enharmonic;
    /**
     * @param alteration alteration to compare
     * @returns `true` if the current note alteration it's below the provided alteration.
     *
     * Compare the current note alteration with the provided one.
     *
     * e.g:
     *
     * ```
let isAltBelow = Note
    .parse('C#')
    .isAlterationBelow(NoteAlteration.FLAT)

isAltBelow // false
```
     *
     *
     */
    isAlterationBelow(alteration: NoteAlteration): boolean;
    /**
     * @param note
     * @returns the distance between the current note and the provided
     *
     * e.g:
    ```
let g = Note.parse('G')
let a = Note.parse('A')

let distance = g.distanceOf(a)
// { notes : 1, semitones : 2 }
    ```
     */
    distanceOf(note: Note): NoteDistance;
    /**
     *
     * @param note
     * @returns the interval between the current note and the provided one.
     */
    intervalOf(note: Note): Interval;
    /**
     * @param distance
     * @returns the trasposed note
     *
     * e.g:
     ```
    let noteA = Note.parse('A')
    let distance = { notes: 1, semitones : 2 }
    
    noteA.traspose(distance) // B
     ```
     
     */
    traspose(distance: NoteDistance): Note;
    /**
     * @param fromTonality The current tonality context of the note
     * @param toTonality The desired tonality context for the note
     * @returns the note trasposed to represent the same interval in the new
     * tonality as was in the current.
     *
     * e.g:
```
let noteA = Note.parse('A')
let currentTonality = Note.parse('C')
let newTonality = Note.parse('D')

noteA.traspose(currentTonality, newTonality) // B

```

In the example, `A` represent a `6M` in `C`, as `B` is a `6M` in D.
     */
    trasposeTonality(fromTonality: Note, toTonality: Note): Note;
    /**
     *
     * @param notation optional parameter. American by default.
     * @returns the note as String
     *
     * e.g with American:
    
     ```
    Note.parse('A').toString() // "A"
    Note.parse('A').toString(Notation.AMERICAN) // "A"
    ```
    *
    * e.g with Southern European:
    
     ```
    Note.parse('A').toString(Notation.SOUTHERN_EUROPEAN) // "LA"
     ```
     */
    toString(notation?: Notation): string;
    equals(note: Note): boolean;
    /**
     *
     * @param note note in American or SouthernEuropean Notation
     */
    static parse(note: string): Note;
    static fromNote(note: AmericanNote | SouthernEuropeanNote, alteration?: NoteAlteration): Note;
    static fromNoteAndAbsoluteValue(note: AmericanNote, absoluteValue: number): Note;
    static allNotes(): Note[];
}
